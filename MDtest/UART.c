#include "GV.h"

void UART_Init( void )
{
	//UARTに使用する設定レジスタ
	TXSTA = 0b00100100;		//送信情報設定
						    //Bit 7: 意味なし
							//Bit 6: 0=8ビットデータで送信（パリティ無） 1=9ビットデータで送信（パリティ有）
							//Bit 5: 送信許可のビット 1にして許可
							//Bit 4: USARTモードの指定　0として非同期モードに
							//Bit 3: ブレーク文字送信指定ビット　通常は0
							//Bit 2: 高速ボーレートの指定ビット　通常は1
						 	//Bit 1: 送信レジスタの状態を得るビット 1だと空 0だと未送信
						 	//Bit 0: ９ビット目のデータ用

	RCSTA = 0b10010000;		//受信情報設定
							//Bit 7: シリアルピン使用の指定ビット 
							//		 1:（RX:TX）のピンはシリアルポートとして使用する
							//		 0:（RX:TX）のピンはI/Oポートとして使用する
							//Bit 6: 9ビットでの受信指定ポート 0として８ビットで受信する
							//Bit 5: シグナル受信許可の指定ビット　なお、非同期モードでは無意味
							//Bit 4: 連続受信許可の指定ビット 通常は1
							//Bit 3:　RX9（Bit6）が"1"の時、アドレス検出許可ビットの指定ビット 通常は0
							//Bit 2:　フレーミングエラーのステータスビット 
							//Bit 1:　オーバーランエラーのステータスビット 
							//Bit 0: ９ビット目のデータ用
							
	SPBRG = 207;    //ボーレートを9600に設定  詳しくはデータシート229P
					//今回 SYNC=0; BRGH=1; BRG16=0なので、 SPBRG=207と設定する。
	ADDEN = 0;			
	
	TRISC = TRISC | 0b10000000;  //TX（送信）:RC6 RX(受信):RC7
	TRISC = TRISC & 0b10111111;
	
	__delay_ms(10);
	
	GIE = 1;  	//全割り込み処理許可
	PEIE = 1; 	//周辺装置割り込みを有効化
	RCIE = 1;   //UARTの割り込み受信を有効にする
	RCIF = 0;   //UAR割り込み受信フラグを初期化
	
	__delay_ms(10);			
}	

void UART_Interrupt( void )
{
	if(RCIF == 1){   //UARTの通信で割り込みが発生
		RCIF = 0;
		RCV_Buff = RCREG;  //受信データを格納
		
		if('a' <= RCV_Buff && RCV_Buff <= 'z'){   //RCREGは送信をするとなぜか0x0Aが格納されてしまう
			UART_data = RCV_Buff;      			  //故に受け取った瞬間に別の変数に格納するか、フラグ立てるかをすると良い
		}
	}			
}

void UART_Send(unsigned char send_data)
{
	TXEN = 1;			//送信許可
	TXREG = send_data;	//送信データ
	__delay_ms(1);		//送信用ディレイ
//	TXEN = 0;			//送信禁止
	TXIF = 1;			//フラグをクリア
}	